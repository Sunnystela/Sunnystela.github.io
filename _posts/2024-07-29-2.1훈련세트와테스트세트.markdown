---
layout: post
title:  "머신러닝 | 2-1. 훈련 세트와 테스트 세트"
date:   2024-07-29 13:11
categories: CUDA MachineLearning 혼공머신 2.데이터다루기
---


### 지도 학습과 비지도 학습의 차이! 모델을 훈련시키는 훈련 세트와 모델을 평가하기 위한 테스트 세트로 데이터를 나눠서 학습

## 지도 학습과 비지도 학습

|지도학습|비지도학습|
|------|---|
|훈련하기 위한 데이터와 정답이 필요하다|필요없다|
|정답(타깃)이 있으니 알고리즘이 정답을 <br> 맞히는 것을 학습한다(도미인지 빙어인지 구분한다)|타깃 없이 입력 데이터만 사용한다. <br> 정답을 사용하지 않으므로 무언가를 맞힐 수 없다. <br> 대신 데이터를 잘 파악하거나 변형하는 데 도움을 준다|

입력 데이터만 있을 때는 비지도 학습 알고리즘을 사용한다


지도학습에서 데이터는 **입력**이고 정답은 **타깃**이다. 이 둘을 합쳐서 **훈련 데이터**라고 부른다

입력으로 사용된 길이와 무게는 **특성**이라고 한다.

![alt 용어](/assets/img/2.1용어.png)


k-최근접 이웃 알고리즘은 입력 데이터와 타깃(정답)을 사용했으므로 지도 학습 알고리즘이다

![alt 종류](/assets/img/2.1종류.png)

## 훈련 세트와 테스트 세트
머신러닝에서 도미와 빙어의 데이터와 타깃을 주고 훈련한 다음 같은 데이터로 테스트한다면? 당연히 모두 맞힌다. 연습문제와 시험 문제가 달라야 한다. 훈련 데이터와 평가에 사용할 데이터가 각각 달라야 한다. 

또 다른 데이터를 준비하거나 이미 준비된 데이터 중에서 일부를 떼어 내어 활용하면 된다. 일반적으로 후자를 사용한다. 평가에 사용하는 데이터를 **데스트 세트**라고 하고 훈련에 사용되는 데이터를 **훈련 세트**라고 한다. 따로 준비되어야 한다.

하나의 생선 데이터를 **샘플**이라고 부른다

일반적으로 리스트처럼 배열의 요소를 선택할 때는 배열의 위치, 즉 **인덱스**를 지정한다. 

인덱스 이외에서 **슬라이싱**도 가능하다. 콜론(:)을 두고 인덱스 번위를 지정하여 여러 개의 원소를 선택할 수 있다. **마지막 인덱스의 원소는 포함되지 않는다**

## 샘플링 편향
![alt 잘못](/assets/img/2.1잘못된.png)
![alt 올바른](/assets/img/2.1올바른.png)

테스트 세트에 빙어만 있으면 안된다. 골고루

훈련 세트와 테스트 세트에 샘플이 골고루 섞여 있지 않으면 샘플링이 한쪽으로 치우쳤다는 의미로 **샘플링 편향**이라고 부른다

특정 종류의 샘플이 과도하게 많은 샘플링 편향을 가지고 있다면 제대로 된 지도 학습 모델을 만들 수 없다

잘 섞어주는 믹서기 열할: 넘파이

## 넘파이

파이썬의 대표적인 배열 라이브러리이다. 파이썬의 리스트에서 고차원으로 표현하려면 번거롭다. 넘파이는 고차원의 배열을 손쉽게 만들고 조작할 수 있는 간편한 도구를 많이 제공ㅎ나다. 
> 배열에서 차원은 좌표계의 축과 같다

1차원 배열은 선, 2차원 배열은 면, 3차우너 배열은 3차원 공간

보통의 x,y 좌표계와 달리 시작점이 왼쪽 아래가 아니고 왼쪽 위부터 시작한다. 이렇게 놓으면 편리한 점이 많다

파이썬 리스트를 넘파이 배열로 바꾸는 방법은 넘파이 array()함수에 파이썬 리스트를 전달하면 된다

```
input_arr=np.array(fish_data)
target_arr=np.array(fish_target)
```

넘파이 배열 객체는 배열의 크기를 알려주는 shapge 속성을 제공한다. 
```
print(input_arr.shape) #(샘플 수, 특성 수) 출력
```

배열에서 랜덤하게 샘플을 선택해 훈련 세트와 테스트 세트로 만든다. 

여기서 input_arr과 target_arr에서 같은 위치는 함께 선택되어야 한다. 
![alt go](/assets/img/2.1go.png)

이렇게 하려면 인덱스값을 잘 기억해야겠군. 하지만 항상 기억할 수는 없다. 다른 방법으로 인덱스를 섞은 다음 input_arr과 target_arr에서 샘플을 선택하면 무작위로 훈련 세트를 나누는 것이다. 

넘파이 arrange() 함수를 사용하면 0에서부터 48까지 1씩 증가하는 인덱스를 만들 수 있다. 다음 인덱스를 랜덤하게 섞는다. 
```
np.random.seed(42)
index=np.arange(49)
np.random.shuffle(index)
```

range(N)은 0부터 N-1까지 1씩 증가하는 배열을 만든다. rangdom패키지 아래 있는 shuffle() 함수는 주어진 배열을 무작위로 섞는다

넘파이는 슬라이싱 외에 **배열 인덱싱**도 있다. 1개의 인덱스가 아닌 여러 개의 인덱스로 한 번에 여러 개의 원소를 선택할 수 있다. 

```
print(input_arr[[1,3]])
#두 번째와 네 번째 샘플을 선택하여 출력
```

## 두 번째 머신러닝 프로그램

```
kn.predict(test_input)
#array([0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0])
```

predict() 메서드의 출력 결과 test_target 출력과 동일하게 array() 로 감싸 있다. 이는 넘파이 배열을 의미한다.

predict()메서드가 반환하는 값은 단순한 파이썬 리스트가 아니라 넘파이 배열이다. 

## 마무리

### 키워드로 끝내는 핵심 포인트
**지도학습**은 입력과 타깃을 전달하여 모델을 훈련한 다음 새로운 데이터를 예측하는 데 활용한다. (ex. k-최근접 이웃)

**비지도 학습**은 타깃 데이터가 없다. 무엇을 예측하는 것이 아니라 입력 데이터에서 어떤 특징을 찾는데 주로 활용한다

**훈련 세트**는 모델을 훈련할 때 사용한다. 훈련 세트가 클수록 좋다. 테스트 세트를 제외한 모든 데이터를 사용한다.

**테스트 세트**는 전체 데이터에서 20~30%를 테스트 세트로 사용하는 경우가 많다. 전체 데이터가 아주 크다면 1%만 덜어내도 충분할 수 있다.


### 핵심 패키지와 함수
#### numpy
**seed()**는 넘파이에서 난수를 생성하기 위한 정수 초깃값을 지정한다. 초깃값이 같으면 동일한 난수를 뽑을 수 있다. 따라서 랜덤 함수의 결과를 동일하게 재현하고 싶을 때 사용한다

**arrange()**는 일정한 간격의 정수 또는 실수 배열을 만든다. 기본 간격은 1이다.     
매개 변수가 1개면 종료 숫자를 의미한다. 종료 숫자는 배열에 포함되지 않는다.     
매개 변수가 2개면 시작 숫자, 종료 숫자를 의미한다    
매개 변수가 3개면 마지막 매개변수가 간격을 나타낸다.

**shuffle()**은 주어진 배열을 랜덤하게 섞는다. 다차원 배열일 경우 첫 번째 축(행)에 대해서만 섞는다.

---
참고: 혼자 공부하는 머신러닝+딥러닝