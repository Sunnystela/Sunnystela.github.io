---
layout: post
title: "[DeepLearning.AI] Course3.W1 Structuring Machine Learning Projects"
date: 2026-01-02 11:50
categories: MyStudy DeepLearning.AI
tags: DeepLearning.AI DeepLearning
math: true
---

[Structuring Machine Learning Projects (Course 3 of the Deep Learning Specialization)](https://www.youtube.com/watch?v=dFX8k1kXhOw&list=PLkDaE6sCZn6E7jZ9sN_xHwSHOdjUxUW_b)


## Improving Model Performance (C3W1L01)

### **1. 강의 주제 소개**
이 강의는 **머신러닝 프로젝트를 구성하는 방법**, 즉 **머신러닝 전략(Machine Learning Strategy)**을 다룹니다. 목표는 여러분의 머신러닝 시스템이 빠르고 효율적으로 돌아가도록 만드는 방법을 배우는 것입니다.

### **2. 성능 개선을 위한 다양한 시도와 예시**
고양이 분류 작업에서 정확도 90%를 얻었지만 성능이 충분하지 않은 상황을 가정해 봅니다. 이때 시스템을 개선하기 위해 다음과 같은 수많은 아이디어를 떠올릴 수 있다.
학습 데이터 더 모으기 (다양한 자세 등)
경사하강법을 더 오래 하거나 Adam 같은 다른 최적화 알고리즘 사용
신경망 크기 조절(더 크거나 작게), 드롭아웃, L2 일반화 적용
네트워크 구조 변경 (활성 함수, 은닉층 수 변경 등)

### **3. 전략 부재의 위험성과 강의의 핵심 가치**
이러한 아이디어 중 잘못된 방법을 선택하면, 최악의 경우 **6개월 동안 데이터를 모으고도 성능 향상이 없어 시간을 낭비**하는 상황이 발생할 수 있다.
따라서 이 강의는 **머신러닝 문제를 분석하는 전략**을 가르쳐주어, 수많은 아이디어 중 **가장 조짐이 좋은(promising) 방법을 빠르고 효율적으로 판단**할 수 있게 돕습니다.
이 내용은 대학 강의 등 다른 곳에서는 접하기 어려운, 실제 딥러닝 제품을 만들며 배운 노하우를 공유한다.

### **4. 마무리**
딥러닝 알고리즘의 세대에 따라 전략은 계속 바뀌고 있으며, 이 아이디어들을 통해 여러분이 **딥러닝 시스템을 더 잘 작동시킬 수 있게 되는 것**이 최종적인 바람입니다.

***

**비유하자면:**  
이 강의는 미로 속에서 무작정 모든 길을 다 가보는 대신, **나침반과 지도(전략)**를 사용하여 출구로 이어질 가능성이 가장 높은 길을 미리 파악하고 효율적으로 움직이는 방법을 알려주는 것과 같습니다.

## 직교화 (C2W1L02)

### **1. 직교화(Orthogonalization)의 개념과 필요성**
머신러닝 시스템 구축이 어려운 이유는 조정해야 할 하이퍼파라미터나 시도해볼 수 있는 변경 사항이 매우 많기 때문입니다.
성공적인 머신러닝 엔지니어들은 원하는 효과를 얻기 위해 **무엇을 조정해야 하는지 명확히 알고 있다.** 이 과정을 **직교화(Orthogonalization)**라고 한다.

### **2. 직교화의 비유: 구형 TV와 자동차**
**TV 예시:**  
옛날 TV에는 화면의 높이, 너비, 회전 등을 조절하는 각각의 버튼이 있었습니다. 만약 하나의 버튼이 높이, 너비, 기울기를 동시에 복합적으로 조절한다면 화면을 원하는 대로 맞추기 불가능할 것입니다. 직교화란 TV 디자이너가 각 버튼이 **하나의 기능만 수행하도록 설계**하여 조작을 쉽게 만드는 것과 같습니다,.
**자동차 예시:**  
운전은 '핸들(조향)'과 '페달(속도)'이라는 독립적인 조작으로 이루어집니다. 만약 핸들을 꺾을 때 속도까지 같이 변하게 설계되어 있다면 운전은 매우 어려울 것입니다. 서로 독립적인(직교하는) 기능을 통해 우리는 차를 원하는 방향과 속도로 쉽게 제어할 수 있다,.

### **3. 머신러닝에서의 4가지 목표와 해결책 (버튼)**
머신러닝 지도 학습이 성공하기 위해서는 다음 4가지 단계를 순차적으로 만족해야 하며, 각 단계에 맞는 독립적인 해결책(버튼)을 사용해야 한다.

1.  **학습 세트(Training Set) 성능 확보**
    목표: 학습 세트에서 사람 수준 등 받아들일 만한 성능을 내야 한다.
    해결책(버튼): 더 큰 신경망(Neural Network) 사용, Adam과 같은 더 나은 최적화 알고리즘 사용.
2.  **개발 세트(Dev Set) 성능 확보**
    목표: 학습된 알고리즘이 개발 세트에서도 잘 작동해야 한다.
    해결책(버튼): 정규화(Regularization), 더 큰 학습 세트 사용.
3.  **시험 세트(Test Set) 성능 확보**
    목표: 개발 세트에서의 성능이 시험 세트까지 이어져야 한다.
    해결책(버튼): 더 큰 개발 세트(Dev Set) 사용 (개발 세트에 과적합된 경우),.
4.  **실제 환경(Real World) 성능 확보**
    목표: 시험 세트 점수가 좋아도 실제 사용자(예: 고양이 앱 사용자)가 만족하지 못하면 비용 함수가 잘못된 것입니다.
    해결책(버튼): 개발 세트의 분포를 바꾸거나 비용 함수(Cost Function) 자체를 변경.

### **4. 조기 종료(Early Stopping)에 대한 견해**
강연자는 **조기 종료(Early Stopping)** 기법을 선호하지 않습니다.
이유: 조기 종료는 학습 세트의 성능(최적화)과 개발 세트의 성능(일반화) 두 가지에 동시에 영향을 미치기 때문입니다. 이는 마치 TV의 높이와 너비를 동시에 바꾸는 버튼과 같아서, 문제를 독립적으로 분석하고 해결하는 '직교화'의 원칙에 덜 부합한다,.

### **5. 결론**
직교화의 핵심은 문제가 발생했을 때(예: 학습 세트 성능 저하, 과적합 등), 그 특정 문제만을 해결할 수 있는 명확한 '버튼'을 사용하는 것입니다.
이를 통해 머신러닝 시스템의 성능을 제한하는 요인을 정확히 진단하고 개선할 수 있다,.


## Single Number Evaluation Metric (C2W1L03)

이 강의의 핵심은 **머신러닝 프로젝트의 진행 속도를 높이기 위해 '단일 실수 평가 기준(Single number evaluation metric)'을 설정해야 한다**는 것입니다.

### **1. 단일 평가 기준의 필요성과 반복 과정의 가속화**
머신러닝을 적용하는 과정은 '아이디어 → 코딩 → 실험 → 결과 관찰'을 반복하며 알고리즘을 개선해 나가는 경험적이고 순환적인 과정입니다. 이때 하이퍼파라미터를 조정하거나 다양한 알고리즘을 시도할 때, 성능을 판단하는 '실수(real number)로 된 하나의 평가 기준'이 있다면, 모델 간의 성능을 빠르게 비교하고 결정할 수 있어 전체 개발 속도가 훨씬 빨라집니다.

### **2. 다중 지표(정밀도와 재현율) 사용 시 발생하는 문제**
고양이 분류기를 예로 들면, 분류기의 성능을 평가하기 위해 **정밀도(Precision)**와 **재현율(Recall)**을 흔히 사용한다.
**정밀도:**  
분류기가 고양이라고 예측한 것 중 실제 고양이의 비율.
**재현율:**  
실제 고양이 사진 중 분류기가 정확히 찾아낸 비율.

이 두 지표는 종종 트레이드오프(Trade-off) 관계에 있다. 문제는 분류기 A가 재현율이 더 좋고, 분류기 B가 정밀도가 더 좋은 경우처럼 두 지표가 엇갈릴 때, 어떤 모델이 더 우수한지 빠르고 명확하게 판단하기 어렵다는 것입니다,.

### **3. 해결책: F1 스코어 (단일 지표로의 통합)**
수많은 분류기를 테스트하고 최상의 모델을 빨리 골라내기 위해서는 두 개의 숫자를 비교하며 고민하는 것보다, 이들을 결합한 새로운 평가 기준을 만드는 것이 좋습니다.
**F1 스코어(F1 Score):**  
정밀도(P)와 재현율(R)의 **조화평균(Harmonic Mean)**으로 정의되며, 공식은 $2 / (1/P + 1/R)$입니다.
단순 산술평균보다 두 지표의 트레이드오프를 더 합리적으로 반영하여 결합한 수치입니다.

### **4. 단일 지표의 이점: 명확한 의사결정**
F1 스코어와 같이 하나의 숫자로 된 평가 기준을 사용하면, 분류기 A와 B 중 어느 것이 더 나은지(F1 스코어가 더 높은지) 즉각적으로 알 수 있어 선택이 매우 빨라집니다. 즉, **개발 세트(Dev set)와 하나의 정량적 평가 기준**을 설정함으로써, 팀은 불필요한 고민 시간을 줄이고 알고리즘 개선의 순환 과정을 더욱 빠르게 반복할 수 있다.

### **5. 또 다른 예시: 평균 오차 계산**
지역별(미국, 중국, 인도 등)로 고양이 앱의 오차율을 따로 분석하는 경우도 마찬가지입니다. 4개 지역의 오차율을 모두 나열해두면, 어떤 알고리즘이 종합적으로 더 나은지 한눈에 파악하기 어렵습니다.
이때도 지역별 성능을 분석하는 것에 그치지 않고, **오차율의 평균**을 계산하여 하나의 지표로 만듭니다. 평균 오차가 가장 낮은 알고리즘을 선택하는 식으로 기준을 단순화하면, 여러 모델 중 최적의 모델(예: 알고리즘 C)을 신속하게 결정할 수 있다.

**요약하자면,**
이 강의는 머신러닝 팀의 의사결정 효율성을 높이기 위해 여러 평가 지표를 **하나의 정량적 기준(예: F1 스코어, 평균 오차)**으로 통합할 것을 권장한다.

> **비유:**  
여러 명의 달리기 선수를 뽑을 때, '순발력'과 '지구력' 점수를 따로따로 보고 고민하는 것보다, 두 점수를 합산한 '종합 점수' 하나를 기준으로 삼으면 1등 선수를 훨씬 빨리 선발할 수 있는 것과 같습니다.



## Satisficing and Optimizing Metrics (C2W1L04)

### **1. 단일 실수 평가 기준 설정의 어려움과 대안**
여러분이 중요하게 생각하는 여러 가지 평가 요소(예: 정확도, 실행 시간 등)를 하나의 실수 값으로 합치는 것(선형 결합 등)은 종종 인위적이고 어려울 수 있다.
이때 **만족 척도(Satisficing Metric)**와 **최적화 척도(Optimizing Metric)**를 구분하여 설정하는 것이 유용한다.

### **2. 고양이 분류기 예시를 통한 개념 정의**
**상황:**  
분류기의 '정확도'와 이미지 분류에 걸리는 '실행 시간' 두 가지를 고려해야 하는 경우.
**해결책:**  
    **최적화 척도(Optimizing Metric):**  
가능한 한 성능을 최대로 높이고자 하는 척도입니다. 예시에서는 **정확도**가 이에 해당한다.
    **조건 척도(Satisficing Metric):**  
    특정 임계치만 넘으면 그 이상은 크게 신경 쓰지 않는 척도입니다. 예시에서는 **실행 시간(100ms 미만)**이 이에 해당한다,.
**결과:**  
실행 시간이 100ms 미만인 모델들 중에서 가장 정확도가 높은 모델(예: 분류기 B)을 선택하는 방식으로 의사결정이 명료해집니다.

### **3. N개의 지표에 대한 일반적인 적용 규칙**
고려해야 할 지표가 N개일 때, **1개를 최적화 척도**로 설정하여 최대한 좋게 만들고, 나머지 **N-1개를 조건 척도**로 설정하여 특정 기준만 통과하도록 만드는 것이 일반적인 방법입니다.

### **4. 음성 인식(유발 단어 감지) 시스템 예시**
아마존 알렉사나 시리 같은 시스템에서 '유발 단어(Wake word)'를 감지할 때도 이 방법을 적용할 수 있다.
**최적화 척도:**  
유발 단어를 말했을 때 장치가 깨어나는 **정확도**를 최대화한다.
**조건 척도:**  
사용자가 부르지 않았는데 깨어나는 '거짓 양성(False Positive)' 빈도를 **24시간에 1회 이하**가 되도록 제한한다.

### **5. 결론 및 다음 단계**
이러한 방식을 사용하면 여러 분류기 모델 중 조건 척도를 만족하면서 최적화 척도가 가장 높은 최고의 모델을 빠르고 자동으로 선별할 수 있다.
이러한 평가 척도들은 학습(Train), 개발(Dev), 시험(Test) 세트에 대해 계산되어야 하며, 다음 영상에서는 이 세트들을 설정하는 방법에 대해 다룰 예정입니다.



## Train/Dev/Test Set Distributions (C2W1L05)

### **1. 머신러닝 개발 워크플로우와 데이터 세트의 중요성**
데이터 세트를 어떻게 설정하느냐는 팀의 작업 속도와 효율성에 지대한 영향을 미칩니다. 일반적인 머신러닝 개발 흐름은 다음과 같습니다.
다양한 아이디어로 모델을 학습시킵니다.
**개발 세트(Dev set, 교차 검증 세트)**를 사용해 각 모델을 평가하고 가장 좋은 것을 선택한다.
만족스러운 성능이 나올 때까지 이 과정을 반복한 뒤, 마지막에 **시험 세트(Test set)**로 최종 평가를 수행한다.

### **2. 잘못된 데이터 분할 방식: 서로 다른 분포**
여러 지역(미국, 영국, 남미, 아시아 등)에서 서비스를 제공하는 상황을 가정해 봅시다.
**나쁜 방법:**  
특정 지역(예: 미국, 영국 등)의 데이터를 개발 세트로 쓰고, 나머지 지역의 데이터를 시험 세트로 쓰는 것입니다.
**이유:**  
이렇게 하면 개발 세트와 시험 세트가 서로 다른 출처에서 만들어져 **데이터의 분포(distribution)**가 달라지기 때문입니다.

### **3. '과녁(Target)' 비유를 통한 문제 설명**
앤드류 응 교수는 개발 세트와 평가 척도를 설정하는 것을 **"팀에게 과녁의 위치를 알려주는 것"**에 비유한다.
팀은 개발 세트라는 과녁을 맞히기 위해 끊임없이 화살을 쏘며(모델을 개선하며) 최적화한다.
만약 개발 세트와 시험 세트의 분포가 다르면, 팀이 몇 달을 고생해 개발 세트라는 과녁을 명중시켰는데, 막상 시험 단계에서는 **과녁이 다른 위치로 옮겨져 있는 것**을 발견하게 됩니다.
이는 결국 팀이 쏟은 시간을 낭비하게 만듭니다.

### **4. 실제 실패 사례: 대출 승인 모델**
강의에서는 실제 사례를 들어 분포 불일치의 위험성을 경고한다.
한 팀이 대출 상환 예측 모델을 만들면서, **개발 세트는 '중산층'** 우편번호 데이터로, **시험 세트는 '저소득층'** 데이터로 설정했습니다.
두 집단의 데이터 분포는 매우 달랐고, 중산층 데이터에 최적화된 모델은 저소득층 데이터인 시험 세트에서 형편없는 성능을 보였습니다.
결과적으로 이 팀은 3개월간의 작업을 낭비하고 처음부터 다시 시작해야 했습니다.

### **5. 핵심 결론: 동일한 분포(Same Distribution) 사용**
시간 낭비를 막고 효율적으로 목표를 달성하기 위한 핵심 조언은 다음과 같습니다.
모든 데이터를 무작위로 섞은 뒤 개발 세트와 시험 세트를 나누어, 두 세트가 **반드시 동일한 분포**를 갖도록 해야 한다,.
개발 세트와 시험 세트는 미래에 실제 사용할 데이터이자 좋은 성과를 내고 싶은 데이터 중에서 골라야 한다.
이렇게 설정해야 팀이 **올바른 하나의 과녁**을 향해 효율적으로 반복 작업을 수행할 수 있다.

강의는 이 가이드라인을 따르는 것만으로도 머신러닝 팀이 수개월의 시간을 절약할 수 있다고 강조하며 마무리됩니다.

---
**요약 비유:**  
이 강의의 핵심을 비유하자면, **"양궁 선수가 연습할 때 쏘는 과녁(개발 세트)과 실제 올림픽 경기에서 쏘는 과녁(시험 세트)은 같은 위치, 같은 모양이어야 한다"**는 것입니다. 연습 때는 10m 앞의 과녁을 쏘게 하고, 실제 경기에서는 갑자기 50m 뒤의 과녁을 맞히라고 한다면 그동안의 연습은 헛수고가 되기 때문입니다.

## 개발 및 테스트 세트 크기 (C2W1L06)
### **1. 과거의 데이터 분할 관행 (소규모 데이터 시대)**
머신러닝 학문 초기에는 데이터 세트의 크기가 100개에서 10,000개 정도로 작았습니다.
이때는 전체 데이터를 학습(Train)과 시험(Test)으로 7:3으로 나누거나, 학습:개발(Dev):시험을 60:20:20으로 나누는 경험 법칙이 합리적이었습니다.

### **2. 빅데이터 시대의 변화된 비율 (대규모 데이터 시대)**
현대 딥러닝에서는 100만 개 이상의 대규모 예시를 다루는 경우가 많아 가이드라인이 바뀌었습니다.
데이터가 100만 개라면 개발 세트와 시험 세트에 각각 1%만 할당해도 10,000개이므로 충분한 양이 됩니다.
딥러닝 알고리즘은 많은 학습 데이터를 필요로 하므로, 98%(학습):1%(개발):1%(시험)과 같이 학습 데이터에 압도적인 비율을 할당하는 것이 더 합리적입니다.

### **3. 시험 세트(Test Set)의 목적과 적정 크기**
시험 세트의 목적은 개발이 끝난 후 최종 시스템의 성능을 평가하는 것입니다.
전체 성능을 대변할 수 있을 정도로만 크면 되기 때문에, 전체 데이터의 20~30%를 할애할 필요 없이 1만 개나 10만 개 정도의 절대적인 수치만 확보되면 충분한다.

### **4. 시험 세트가 없는 경우**
시스템의 성능에 대한 아주 높은 신뢰도가 필요 없거나 바로 배포하는 경우, 시험 세트 없이 학습과 개발 세트만 운영하기도 한다.
사람들이 흔히 '시험 세트'라고 부르면서 이를 이용해 모델을 반복적으로 조정(tuning)하는 경우가 있는데, 이는 사실상 '개발 세트' 역할을 하는 것이므로 용어를 명확히 하는 것이 좋습니다.
강연자는 편향 없는 최종 평가를 위해 독립적인 시험 세트를 두는 것을 추천하지만, 개발 세트가 매우 크다면 시험 세트를 생략하는 것도 가능은 한다.

### **5. 요약 및 결론**
빅데이터 시대에 과거의 70:30 법칙은 더 이상 적용되지 않습니다.
데이터가 아주 클 때는 학습에 대부분의 데이터를 쓰고, 개발과 시험 세트에는 알고리즘을 비교하거나 최종 성능을 평가하는 데 필요한 만큼의 데이터만 할당하면 됩니다.

***

**비유하자면:**  
국(데이터)의 맛을 보기 위해 국물을 떠먹을 때(평가), 국그릇처럼 양이 적다면(소규모 데이터) 한 숟가락이 전체의 20%를 차지할 수도 있다. 하지만 **거대한 가마솥에 국이 가득하다면(빅데이터)**, 굳이 전체의 20%를 다 마셔볼 필요 없이 **똑같이 한 숟가락(절대적인 양)**만 맛보아도 충분히 간을 맞출 수 있는 것과 같은 원리입니다.




## 개발/테스트 세트를 변경해야 하는 경우 (C2W1L07)

### **1. 문제 상황: 평가 척도와 실제 선호도의 불일치**
강의는 개발 세트와 평가 척도를 정하는 것이 '과녁'을 정하는 것과 같다는 비유로 시작한다.
**예시:**  
고양이 분류기를 만들 때, 알고리즘 A는 오차율 3%지만 '야한 사진'을 걸러내지 못하고, 알고리즘 B는 오차율 5%지만 야한 사진을 완벽히 차단한다고 가정한다.
**모순:**  
현재의 '분류 오차' 척도로는 A가 더 우수한 알고리즘입니다. 하지만 회사나 사용자 입장에서는 야한 사진을 보여주는 A보다, 오차가 조금 더 크더라도 안전한 B를 선호한다.
**결론:**  
평가 척도가 매기는 순위(A>B)와 실제 선호 순위(B>A)가 다르다면, 평가 척도를 변경해야 한다는 신호입니다.

### **2. 해결책: 가중치(Weight)를 적용한 새로운 척도 정의**
기존 척도의 문제는 모든 오차를 동등하게 취급한다는 점입니다.
**수정 방법:**  
오차 함수에 가중치($w^{(i)}$)를 도입한다. 예를 들어, 야한 사진을 잘못 분류했을 때는 가중치를 10이나 100처럼 크게 주어 페널티를 강화한다.
**목표:**  
이렇게 하면 야한 사진을 실수로 통과시키는 알고리즘의 오차 값이 훨씬 커지게 되어, 우리가 선호하는 알고리즘(B)이 더 좋은 점수를 받도록 척도를 수정할 수 있다.

### **3. 머신러닝 전략의 핵심: 직교화(Orthogonalization)**
이 과정은 머신러닝 문제를 서로 다른 단계로 쪼개는 '직교화'의 예시입니다.
**1단계(과녁 놓기):**  
무엇이 좋은 결과인지 정의하는 단계입니다. 평가 척도를 정의하는 것이 여기에 해당한다.
**2단계(과녁 맞추기):**  
정의된 척도에서 좋은 성능을 내기 위해 알고리즘을 최적화(Cost function $J$ 최소화)하는 단계입니다.
이 두 단계는 분리해서 생각해야 한다. 만약 목표가 잘못되었다면, 사격 실력을 탓할 게 아니라 과녁의 위치(척도)를 먼저 옮겨야 한다.

### **4. 또 다른 문제 상황: 데이터 분포의 불일치**
평가 척도뿐만 아니라 개발/시험 세트 자체를 바꿔야 하는 경우도 있다.
**예시:**  
개발/시험 세트는 인터넷에서 긁어온 고화질 고양이 사진으로 구성되어 있는데, 실제 앱 사용자들은 흐릿하거나 구도가 이상한 저화질 사진을 업로드하는 경우입니다.
**증상:**  
개발 세트에서는 A가 잘 작동하지만, 실제 앱 환경에서는 B가 더 잘 작동하는 현상이 발생한다.
**해결책:**  
개발/시험 세트가 실제 운영 환경(저화질 사진 등)을 반영하지 못한다면, 데이터를 실제 사용자가 올리는 데이터와 비슷한 것으로 전면 교체해야 한다.

### **5. 결론 및 가이드라인**
현재의 척도나 데이터가 실제 프로젝트에서 중요하게 여기는 가치를 반영하지 못한다면, 주저하지 말고 **새로운 척도를 정의하거나 개발/시험 세트를 변경**해야 한다.
설령 완벽하지 않더라도 일단 척도를 정해서 개발 속도를 높이고, 나중에 문제가 발견되면 그때 수정하는 것이 전략적으로 더 효율적입니다.

***

**비유로 요약하자면:**  
사격 대회에서 과녁의 정중앙(기존 척도)을 맞췄는데 심판이 점수를 주지 않는다면, 억지로 계속 쏘는 대신 **과녁 자체를 심판이 원하는 위치(실제 비즈니스 목표)로 옮겨야** 한다는 것이 이 강의의 핵심입니다.



## Why Human Level Performance (C2W1L08)

### **1. 머신러닝 성능을 사람 수준과 비교하는 이유**
최근 많은 연구팀이 머신러닝 시스템을 사람의 성능과 비교한다. 그 이유는 크게 두 가지입니다.
딥러닝의 발전으로 알고리즘이 사람과 경쟁할 수 있는 수준에 도달했기 때문입니다.
사람이 할 수 있는 작업을 수행하도록 시스템을 설계하고 만드는 것이 더 효율적이기 때문입니다.

### **2. 성능 향상 곡선과 한계 (베이지안 최적 오차)**
머신러닝 모델의 성능은 사람 수준에 근접할 때까지는 빠르게 향상되지만, 사람을 뛰어넘은 이후에는 그 속도가 느려집니다.
모델의 성능은 **베이지안 최적 오차(Bayes optimal error)**라는 이론적 한계를 넘을 수 없습니다.
데이터 자체의 노이즈(예: 너무 잡음이 심한 오디오, 흐릿한 이미지) 때문에 100% 정확도는 달성 불가능하며, 베이지안 오차는 달성 가능한 최소의 오차 값을 의미한다.

### **3. 사람 수준을 넘어서면 발전이 느려지는 이유**
알고리즘이 사람 성능을 초과하면 성능 향상이 더뎌지는데, 여기에는 두 가지 주요한 이유가 있다.
**한계 근접:**  
이미지 인식이나 음성 인식 등 사람이 잘하는 태스크의 경우, 사람의 성능이 이미 베이지안 최적 오차(이론적 한계)에 매우 근접해 있어 더 개선할 여지가 적습니다.
**도구의 부재:**  
알고리즘이 사람보다 성능이 낮을 때는 성능을 높일 수 있는 명확한 방법들이 존재하지만, 사람을 넘어서면 이러한 방법들을 적용하기 어려워집니다,.

### **4. 사람보다 성능이 낮을 때 활용 가능한 전략**
알고리즘이 사람보다 못할 때(Human level > ML performance)는 다음과 같은 효과적인 도구들을 사용하여 성능을 빠르게 올릴 수 있다.
**라벨링:**  
사람에게 데이터 라벨링을 부탁하여 학습 데이터를 늘릴 수 있다.
**오차 분석:**  
알고리즘이 틀린 예시를 사람이 직접 확인하여 왜 틀렸는지 분석하고 통찰을 얻을 수 있다.
**편향/분산 분석:**  
사람의 성능을 기준으로 삼아 편향(Bias)과 분산(Variance)을 얼마나 줄여야 하는지 더 잘 파악할 수 있다.

**결론적으로,** 사람의 성능을 파악하는 것은 특히 사람이 잘하는 태스크에서 알고리즘의 개선 방향(편향 및 분산 조절 등)을 잡는 데 매우 중요한 기준이 됩니다.



## Avoidable Bias (C2W1L09)
이 강의의 핵심은 **사람 수준의 성능(Human-level performance)**을 기준으로 **편향(Bias)**과 **분산(Variance)** 중 무엇을 먼저 줄여야 할지 결정하는 방법입니다.

### **1. 사람 수준 성능과 학습 오차의 비교 (예시 1)**
**상황:**  
고양이 분류 문제에서 사람의 오차가 **1%**라고 가정한다. 반면, 학습 알고리즘의 **학습 오차(Training Error)는 8%**, **개발 오차(Dev Error)는 10%**입니다.
**분석:**  
알고리즘이 학습 데이터조차 사람만큼 잘 맞추지 못하고 있다(1% vs 8%). 이는 알고리즘이 학습 세트에 충분히 적합(fit)되지 않았음을 의미한다.
**전략:**  
이 경우 **편향(Bias)을 줄이는 데 집중**해야 한다. 더 큰 신경망을 쓰거나 경사하강법을 더 오래 실행하는 방법 등이 있다.

### **2. 베이지안 오차와 목표 수정 (예시 2)**
**상황:**  
위와 동일하게 학습 오차 8%, 개발 오차 10%인 상황입니다. 하지만 이번에는 데이터의 이미지 화질이 나빠서 **사람의 오차도 7.5%**나 되는 어려운 데이터셋이라고 가정해 봅니다.
**분석:**  
학습 오차(8%)가 사람 수준(7.5%)에 매우 근접했습니다. 사람의 오차를 이론적으로 도달 가능한 최소 오차인 **베이지안 오차(Bayesian Error)**의 추정치로 본다면, 학습 오차를 이보다 더 줄이려는 시도는 과대적합(Overfitting)을 유발할 수 있다.
**전략:**  
이제 학습 오차를 줄일 공간은 별로 없습니다. 대신 학습 오차(8%)와 개발 오차(10%) 사이의 간격인 2%를 줄이는 것이 더 효과적입니다. 즉, **분산(Variance)을 줄이는 데 집중**해야 하며, 정규화(Regularization)나 더 많은 데이터를 사용하는 방법이 유효한다.

### **3. 새로운 용어 정의: 회피 가능 편향 (Avoidable Bias)**
이러한 판단을 명확히 하기 위해 앤드류 응 교수는 다음과 같은 용어를 정의한다.
**회피 가능 편향 (Avoidable Bias):**  
학습 오차와 베이지안 오차(또는 사람 수준의 오차) 간의 차이입니다. 우리가 '노력해서 줄일 수 있는 편향'을 의미한다.
**분산 (Variance):**  
학습 오차와 개발 오차 간의 차이입니다.

### **4. 전략적 의사결정 방법**
두 가지 예시를 '회피 가능 편향'과 '분산'의 관점에서 다시 정리하면 다음과 같습니다.
**예시 1 (사람 1%, 학습 8%, 개발 10%):**  
    회피 가능 편향: 7% (8% - 1%)
    분산: 2% (10% - 8%)
    **결론:**  
    회피 가능 편향이 더 크므로 **편향**을 줄이는 데 집중한다.
**예시 2 (사람 7.5%, 학습 8%, 개발 10%):**  
    회피 가능 편향: 0.5% (8% - 7.5%)
    분산: 2% (10% - 8%)
    **결론:**  
    분산이 더 크므로 **분산**을 줄이는 데 집중한다.

### **5. 요약**
사람 수준의 성능(베이지안 오차의 추정치)을 알면, 현재 모델의 성능 중 **어느 부분(편향 vs 분산)을 개선하는 것이 더 가능성 높고 효율적인지** 명확하게 판단할 수 있다.

***

**비유하자면:**  
시험 점수를 올리고 싶은 학생(모델)이 있다.
만약 전교 1등(사람/베이지안 오차)이 100점을 받는데 내가 80점이라면, 기본 개념 공부(편향 줄이기)가 더 필요한다.
만약 시험이 너무 어려워서 전교 1등도 82점을 받는데 내가 80점이라면, 기본 공부를 더 하는 건 큰 효과가 없습니다. 대신 모의고사 점수와 실전 점수의 차이(분산)를 줄이는 컨디션 조절(정규화)에 집중하는 것이 낫습니다.



## Understanding Human-Level Performance? (C2W1L10)

### **1. 사람 수준 성능의 정의와 베이지안 오차**
**다양한 기준:**  
의료 사진 분류 예시를 들면, 비숙련자(3% 오차), 일반 의사(1%), 숙련된 의사(0.7%), 숙련된 의사 팀(0.5%) 등 '사람 수준'에 대한 기준은 다양한다.
**베이지안 오차 추정:**  
머신러닝 전략 수립 시, 사람 수준의 성능은 **베이지안 오차(Bayes Error, 이론적으로 달성 가능한 최소 오차)**의 추정치로 활용됩니다.
**최적의 기준 선택:**  
베이지안 오차는 이론적 한계치이므로, 가능한 가장 낮은 오차율(예: 의사 팀의 0.5%)을 베이지안 오차의 추정치로 삼는 것이 적절한다. 다만, 단순히 시스템 배포가 목적이라면 일반 의사 수준을 넘어서는 것만으로도 충분할 수 있다.

### **2. 오차 분석을 통한 전략 수립 (회피 가능 편향 vs 분산)**
사람 수준의 성능(베이지안 오차 추정치)을 기준으로 학습 오차와 개발 오차를 분석하여 **회피 가능 편향(Avoidable Bias)**과 **분산(Variance)** 중 무엇을 줄여야 할지 결정한다.

**상황 A (편향 문제):**  
학습 오차 5%, 개발 오차 6%.
    사람 수준(0.5%)과 학습 오차(5%)의 차이가 큽니다. 이를 **회피 가능 편향**이라고 한다.
    이 경우 분산(1%)보다 편향 문제가 더 크므로, 편향을 줄이는 데(예: 더 큰 네트워크, 더 긴 학습) 집중해야 한다,.
**상황 B (분산 문제):**  
학습 오차 1%, 개발 오차 5%.
    학습 오차(1%)가 사람 수준(0.5%)에 근접하여 회피 가능 편향은 작습니다.
    반면 개발 오차와의 차이(4%)인 **분산**이 훨씬 크므로, 분산을 줄이는 데(예: 정규화, 데이터 추가) 집중해야 한다.

### **3. 사람 수준에 근접할 때의 어려움**
**상황 C (판단 불가):**  
학습 오차 0.7%, 개발 오차 0.8%.
    이때는 베이지안 오차를 0.5%로 보느냐 0.7%로 보느냐에 따라 전략이 완전히 달라집니다.
    성능이 사람 수준에 매우 근접하면, 베이지안 오차를 정확히 추정하기 어려워져 편향과 분산 중 무엇을 우선 해결해야 할지 명확히 알 수 없게 됩니다. 이것이 사람 수준을 넘어서면 성능 향상이 더뎌지는 이유입니다,.

### **4. 요약 및 결론**
**용어 정리:**  
    **회피 가능 편향(Avoidable Bias):**  
학습 오차 - 베이지안 오차(사람 수준 성능). 학습 알고리즘이 이론적 한계에 얼마나 못 미치는지 보여줍니다.
    **분산(Variance):**  
    개발 오차 - 학습 오차. 알고리즘이 얼마나 일반화를 못 하고 있는지 보여줍니다.
**핵심 가치:**  
이전 강의들에서는 편의상 최적 오차를 0%로 가정했지만, 실제 데이터(노이즈가 많은 음성 등)는 베이지안 오차가 0%가 아닐 수 있다. 이때 **사람 수준 성능**을 척도로 삼으면, 불가능한 0%가 아니라 **도달 가능한 목표(베이지안 오차)**를 설정하고 효율적인 전략을 짤 수 있다.
이 방법은 모델이 사람 수준을 뛰어넘기 전까지 매우 유용하게 작동한다,.

***

**비유하자면:**  
이 과정은 산 정상(베이지안 오차)을 향해 올라가는 것과 같습니다.
우리는 구름에 가려진 진짜 정상의 위치를 모르기 때문에, **가장 높이 올라간 산악인(사람 수준 성능)**의 위치를 임시 목표로 삼습니다.
내가 산악인보다 훨씬 아래에 있다면(상황 A), 일단 위로 올라가는 것(편향 줄이기)에 집중하면 됩니다.
하지만 이미 산악인만큼 높이 올라왔다면(상황 C), 진짜 정상이 바로 머리 위인지, 아니면 아직 더 높은 봉우리가 숨겨져 있는지 알기 어려워져서 다음 발걸음을 어디로 떼야 할지 결정하기 힘들어집니다.



## Surpassing Human-Level Performance (C2W1L11)

### **1. 인간 수준 성능을 능가했을 때의 어려움 (오차 분석의 모호함)**
**분석이 쉬운 경우:**  
알고리즘의 성능이 아직 인간 수준에 미치지 못할 때는 개선 방향을 잡기 쉽습니다. 예를 들어, 인간(전문가 팀)의 오차가 0.5%인데 알고리즘의 학습 오차가 0.6%, 개발 오차가 0.8%라면, '회피 가능 편향(Avoidable Bias)'이 0.1%임을 알 수 있어 분산을 줄이는 데 집중해야 한다는 결론을 쉽게 내릴 수 있다.
**분석이 어려운 경우:**  
만약 학습 오차가 0.3%, 개발 오차가 0.4%로 인간의 오차(0.5%)보다 더 낮아졌다면 문제가 복잡해집니다. 이때는 과대 적합(Overfitting)이 발생한 것인지, 아니면 베이지안 오차(최적의 한계치)가 실제로 매우 낮은 것인지 판단할 정보가 부족해지기 때문입니다.
**결과:**  
인간 성능을 넘어서는 순간, 편향과 분산 중 무엇을 줄여야 할지 명확히 알기 어려워지며, 인간의 직관에 의존하여 알고리즘을 개선하는 도구들의 효율성이 떨어지게 됩니다.

### **2. 기계가 이미 인간을 능가한 분야 (구조화된 데이터)**
오늘날 머신러닝이 인간보다 뛰어난 성능을 보이는 문제들은 주로 **구조화된 데이터(Structured Data)**를 다루는 영역입니다.
**예시:**  
온라인 광고 클릭 예측, 영화나 책 추천 시스템, 물류 배송 시간 예측, 대출 승인 여부 예측 등.
이러한 시스템은 인간이 볼 수 있는 것보다 훨씬 방대한 양의 데이터베이스를 기반으로 통계적 패턴을 찾아내기 때문에 인간보다 성능이 뛰어나기 쉽습니다.

### **3. 자연 인지 태스크에서의 도전과 발전**
컴퓨터 비전, 음성 인식, 자연어 처리와 같은 **자연 인지(Natural Perception)** 태스크는 인간이 본능적으로 매우 능숙하기 때문에 컴퓨터가 인간을 넘어서는 것이 구조화된 데이터 문제보다 훨씬 어렵습니다.
하지만 최근에는 음성 인식이나, ECG(심전도) 판독, 피부암 진단, 방사선과 같은 특정 의료 영상 분석 분야에서도 컴퓨터가 단일 인간의 성능을 능가하는 사례가 등장하고 있다.

### **4. 결론**
인간의 성능을 뛰어넘는 것은 결코 쉬운 일이 아니지만, 충분한 데이터가 뒷받침된다면 딥러닝 시스템을 통해 많은 지도 학습 문제에서 인간 수준을 초월하는 성과를 낼 수 있다.



## Improving Model Performance (C2W1L12)

### **1. 지도 학습의 두 가지 핵심 목표**
지도 학습 알고리즘이 성공적으로 작동하기 위해서는 다음 두 가지 단계를 순차적으로 달성해야 한다.
**학습 세트 성능 확보:**  
학습 데이터에 잘 맞아들어가야 한다. 이는 **'회피 가능 편향(Avoidable Bias)'을 줄이는 것**과 같습니다.
**일반화 성능 확보:**  
학습 세트에서의 성능이 개발(Dev) 및 시험(Test) 세트에서도 유지되어야 한다. 이는 **'분산(Variance)'이 나쁘지 않도록 관리하는 것**입니다.

### **2. 문제 진단 방법**
성능 향상을 위해서는 현재 시스템의 병목이 무엇인지 먼저 파악해야 한다.
**회피 가능 편향 진단:**  
'베이지안 오차(사람 수준 성능)'와 '학습 오차'의 차이를 확인한다. 이 차이가 크다면 학습 세트에서 성능을 더 높여야 함을 의미한다.
**분산 진단:**  
'학습 오차'와 '개발 오차'의 차이를 확인한다. 이 차이가 크다면 모델이 일반화되지 못하고 있음을 의미한다.

### **3. 회피 가능 편향(Avoidable Bias) 해결책**
편향이 문제인 경우, 즉 학습 세트 성능이 부족할 때는 다음과 같은 '버튼'들을 조작해야 한다,.
더 큰 신경망(모델)을 사용한다.
더 오래 학습시키거나, 모멘텀(Momentum), RMSprop, Adam과 같은 더 나은 최적화 알고리즘을 사용한다.
활성 함수 변경, 은닉층 수 조절 등 신경망 구조나 하이퍼파라미터를 변경한다. (RNN, CNN 등 새로운 구조 시도 포함)

### **4. 분산(Variance) 해결책**
분산이 문제인 경우, 즉 학습 세트에는 잘 맞지만 개발 세트 성능이 떨어질 때는 다음과 같은 해결책을 사용한다,.
더 많은 학습 데이터를 수집한다.
L2 정규화(Regularization)나 드롭아웃(Dropout) 같은 정규화 기법을 적용한다.
데이터 확대(Data Augmentation)를 사용한다.
문제에 더 적합한 신경망 구조나 하이퍼파라미터를 찾습니다.

### **5. 결론: 전략적 우위 확보**
편향과 분산의 개념은 배우기는 쉽지만, 이를 실제 문제 해결에 능숙하게 적용하는 것은 어렵습니다.
이 기본 원칙들을 체계적으로 적용할 수 있다면, 주먹구구식으로 접근하는 다른 머신러닝 팀보다 훨씬 효율적이고 전략적으로 성과를 낼 수 있다.