---
layout: post
title: "[CS231n] 7. Training Neural Networks II"
date: 2026-01-30 09:50
categories: MyStudy CS231n
tags: cv CS231n
math: true
---

강의 주소: <br>
[CS231n Lecture 7. Training Neural Networks II](https://www.youtube.com/watch?v=_JB0AO7QxSA&list=PL3FW7Lu3i5JvHM8ljYj-zLfQRF3EO8sYv&index=7)

자료: <br>
[깃허브 강의 자료](https://github.com/visionNoob/CS231N_17_KOR_SUB?tab=readme-ov-file)






## 1. 지난 강의 복습 
**활성화 함수:**  
과거에는 Sigmoid, Tanh를 썼지만 Vanishing Gradient 문제가 있어 현재는 **ReLU**를 기본으로 사용한다.

**가중치 초기화:**  
가중치가 너무 작으면 신호가 소실되고 너무 크면 폭발한다. Xavier나 MS(He) 초기화를 사용하여 적절한 분산을 유지해야 한다.

**Preprocessing:**  
데이터를 **Zero-center**로 만드는 것이 중요하다.  
    **직관적 이유:**  
    데이터가 원점에서 멀리 떨어져 있으면(Uncentered), 선형 분류기나 신경망 레이어가 파라미터의 미세한 변화에 매우 민감하게 반응하여 손실 함수가 불안정해지고 최적화가 어려워진다.  
    **Batch Normalization:**  
    네트워크 내부의 활성값들을 강제로 가우시안 분포(평균 0, 분산 1)로 만들어주는 기법으로 학습을 돕는다.

**하이퍼파라미터 탐색:**  
처음에는 넓은 Coarse에서 탐색하고 점차 좁은 범위로 좁혀가야 한다.

## 2. Better Optimization
기존의 **확률적 경사 하강법**은 단순하지만 몇 가지 치명적인 문제가 있다.

### (1) SGD의 문제점
1.  **Poor Conditioning:**  
손실 함수 표면이 한 방향으로는 완만하고 다른 방향으로는 가파른 Taco shell 모양일 때, SGD는 가파른 방향으로만 진동하며 실제 목표 지점으로는 매우 느리게 이동한다. 이는 고차원 문제에서 매우 흔하다.
2.  **Local Minima와 Saddle Points:**  
    기울기가 0이 되는 지점에서 SGD는 멈춥니다.
    고차원에서는 모든 방향에서 손실이 증가하는 Local Minima보다 어떤 방향은 증가하고 어떤 방향은 감소하는 **Saddle Point**이 훨씬 더 빈번하게 발생한다.
    안장점 근처에서는 기울기가 매우 작아 학습 속도가 극도로 느려진다.
3.  **Noise:**  
미니 배치를 사용하므로 실제 그레디언트가 아닌 근사값을 사용하게 되어 업데이트 경로가 구불구불해진다.

### (2) SGD + Momentum 
**아이디어:**  
물리적인 관성을 도입한다. 그레디언트 방향으로 바로 이동하는 대신 **속도** 변수를 유지한다.  
**작동:**  
현재 그레디언트를 속도에 더하고(마찰 계수 `rho`로 감쇠), 그 속도 방향으로 파라미터를 업데이트한다.  
**효과:**  
    로컬 미니마나 안장점에서도 축적된 속도 덕분에 멈추지 않고 계속 진행할 수 있습니다.
    진동하는 차원에서는 움직임이 상쇄되고 완만한 차원에서는 속도가 가속되어 더 빠르게 수렴한다.
    노이즈가 섞인 그레디언트들이 평균화되어 더 부드러운 경로로 이동한다.

### (3) Nesterov Momentum
**아이디어:**  
기본 모멘텀은 현재 위치에서 그레디언트를 계산한 뒤 속도를 더하지만 네스테로프는 **속도로 인해 이동할 것으로 예상되는 지점**에서 미리 그레디언트를 계산한다.

**효과:**  
미리 보고 수정하는 효과가 있어 기본 모멘텀보다 오버슈팅이 덜하고 수렴이 안정적이다. 이론적으로 볼록 최적화에서 더 좋은 성능을 보장한다.

### (4) AdaGrad
**아이디어:**  
학습률을 차원별로 조절한다. 그레디언트의 제곱을 계속 더해 나간다(`grad_squared`).

**작동:**  
업데이트 시 그레디언트를 `sqrt(grad_squared)`로 나누어줍니다.

**효과:**  
그레디언트가 큰 차원은 속도를 늦추고 작은 차원은 가속한다.

**문제점:**  
학습이 진행될수록 제곱합이 계속 커져서 학습률이 결국 0이 되어 학습이 멈춘다.

### (5) RMSProp
**아이디어:**  
AdaGrad의 학습 중단 문제를 해결하기 위해 고안되었습니다.

**작동:**  
그레디언트 제곱을 무작정 더하는 대신 **지수 이동 평균**을 사용하여 오래된 정보는 잊고 최근 그레디언트 크기를 반영한다.

**효과:**  
학습이 멈추지 않으면서도 각 차원별로 적절한 속도를 조절한다.

### (6) Adam (Adaptive Moment Estimation)
**아이디어:**  
**Momentum**과 **RMSProp**을 결합한 알고리즘이다.

**작동:**  
    First Moment (Momentum): 그레디언트의 평균을 유지.  
    Second Moment (RMSProp): 그레디언트 제곱의 평균을 유지.

**Bias Correction:**  
초기화 시 0으로 시작하기 때문에 학습 초기에 값이 0에 치우치거나 업데이트가 너무 커지는 것을 방지하기 위해 보정항을 추가한다.

**추천 설정:**  
거의 모든 문제에 **Adam**을 먼저 시도하는 것이 좋다. (Beta1=0.9, Beta2=0.999, learning rate=1e-3 또는 5e-4).

### (7) Learning Rate Decay
**방법:**  
처음에는 높은 학습률로 시작하고 학습이 진행될수록 학습률을 낮춘다.

**유형:**  
계단식 감쇠나 지수적 감쇠 등이 있다.

**팁:**  
Adam보다는 SGD+Momentum을 쓸 때 더 자주 사용된다. 처음부터 튜닝하지 말고 학습 곡선을 보고 필요할 때 적용하는 2차적인 하이퍼파라미터로 생각해야 한다.

### (8) 2차 최적화 
**Newton’s Method:**  
1차 미분뿐만 아니라 2차 미분 정보를 활용하여 2차 함수 근사를 통해 최저점으로 바로 이동한다. 학습률이 필요 없다는 장점이 있다.

**문제점:**  
딥러닝에서는 파라미터 수가 너무 많아 Hessian 행렬($N \times N$)을 계산하고 역행렬을 구하는 것이 불가능하다.

**L-BFGS:**  
Hessian을 근사하는 방식이지만 미니 배치 설정이나 비볼록 문제에서 잘 작동하지 않아 딥러닝 학습에는 잘 쓰이지 않는다. (단 Style Transfer 등 파라미터가 적은 경우에는 사용됨).

## 3. Regularization
Training Error가 아닌 **Test Error**를 줄여 일반화 성능을 높이는 방법들이다.

### (1) Model Ensembles
독립적인 모델 10개를 학습시켜 예측값의 평균을 낸다. 약 2% 정도의 성능 향상을 가져온다.

**팁:**  
학습 중인 모델의 체크포인트들을 저장해 앙상블하거나 파라미터의 이동 평균을 사용하는 방법도 있다.

### (2) Dropout
**방법:**  
학습 중 각 Forward pass마다 임의의 뉴런들을 확률 $p$(보통 0.5)로 꺼버린다(0으로 설정).

**해석:**  
    특징들이 서로 동조하는 것을 막아 특정 특징에 과하게 의존하지 않게 한다.
    단일 모델 안에서 수많은 Sub-network들의 앙상블을 학습하는 효과를 낸다.

**테스트 시:**  
테스트 때는 모든 뉴런을 사용해야 하므로 학습 때의 확률 $p$를 출력값에 곱해주어 기댓값을 맞춰야 한다. 또는 역으로 학습 때 $p$로 나누어주는 **Inverted Dropout**을 사용하여 테스트 시 연산을 줄이기도 한다.

### (3) Data Augmentation
**방법:**  
이미지를 무작위로 변형하여 학습 데이터를 늘립니다. 레이블(정답)은 변하지 않으면서 데이터의 다양성을 확보한다.

**테스트 시:**  
테스트 이미지를 여러 번 크롭하여 평가한 뒤 평균을 낸다.

### (4) 기타 정규화 기법들
**DropConnect:**  
활성값이 아닌 Weight를 임의로 0으로 만든다.

**Fractional Max Pooling:**  
풀링 영역을 랜덤하게 설정한다.

**Stochastic Depth:**  
학습 중 깊은 네트워크의 일부 레이어를 통째로 건너뛴다.

**Batch Normalization:**  
그 자체로도 어느 정도 정규화 효과가 있어 드롭아웃을 대체하기도 한다.

## 4. Transfer Learning
데이터가 부족할 때 사용하는 매우 강력하고 일반적인 전략이다.

**방법:**  
ImageNet과 같은 대규모 데이터셋으로 Pre-trained CNN을 가져옵니다.

**데이터가 적을 때:**  
CNN의 가중치는 Freeze하고 마지막 분류기(Linear Classifier) 층만 내 데이터에 맞게 새로 학습시킨다.

**데이터가 조금 더 많을 때:**  
전체 네트워크 혹은 상위 몇 개의 층을 미세 조정(Fine-tuning)한다. 이때 학습률은 낮게 설정해야 한다.

**결론:**  
거의 모든 컴퓨터 비전 작업에서 바닥부터(From scratch) 학습하는 경우는 드물며 전이 학습이 표준으로 자리 잡았다.

Optimization을 통해 학습 손실을 줄이는 방법(Adam, Momentum 등)과 Regularization를 통해 테스트 성능을 높이는 방법(Dropout, Augmentation 등), 그리고 데이터가 적을 때의 해결책인 Transfer Learning을 다루었다. 
