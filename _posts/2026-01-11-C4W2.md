---
layout: post
title: "[DeepLearning.AI] Course4.W2 Deep Learning Specialization"
date: 2026-01-06 12:50
categories: MyStudy DeepLearning.AI
tags: DeepLearning.AI DeepLearning
math: true
---

[Convolutional Neural Networks (Course 4 of the Deep Learning Specialization)](https://www.youtube.com/watch?v=ArPaAX_PhIs&list=PLkDaE6sCZn6Gl29AoE31iwdVwSG-KnDzF)

## C4W2L01 Why look at case studies?

### **1. 사례 연구를 하는 이유와 중요성**
다른 사람의 코드를 읽으면서 코드 작성법을 익히는 것처럼 **효과적인 신경망을 구축하기 위해서는 이미 검증된 신경망 사례를 살펴보는 것이 가장 좋은 방법**입니다.

한 가지 컴퓨터 비전 작업에서 잘 작동하는 신경망 구조는 **자율 주행과 같은 다른 컴퓨터 비전 작업에도 잘 적용되는 경우**가 많으므로 타인의 신경망 구조를 자신의 작업에 적용해 볼 수 있습니다.

### **2. 강의에서 다룰 주요 신경망 개요**
  **LeNet-5**: 1980년대에 나온 고전적인 신경망.  
    **AlexNet & VGG Net**: 자주 인용되며 현대 컴퓨터 비전의 기틀을 마련한 효과적인 신경망들.  
    **ResNet**: 152개의 층과 같이 아주 깊은 신경망을 훈련시킬 수 있는 흥미로운 개념을 포함함.  
    **Inception Neural Network**


### **3. 다른 분야로의 확장성**
ResNet이나 Inception과 같은 신경망에서 나온 개념들은 컴퓨터 비전 분야가 아니더라도 **다른 분야에서 매우 유용하게 쓰일 수 있습니다**.
따라서 컴퓨터 비전 시스템을 직접 구축하지 않더라도 이러한 개념들을 배우는 것은 큰 도움이 됩니다.



## C4W2L02 Classic Networks


### 1. LeNet-5 (1998년)
초기 CNN의 형태로 손글씨 숫자 인식을 목적으로 개발되었습니다.

**구조 및 특징:**  
    **입력:**  
    32x32x1 크기의 흑백 이미지를 사용합니다.  
    **구성:**  
    5x5 필터(스트라이드 1)를 사용하는 합성곱 층과 2x2 필터(스트라이드 2)를 사용하는 풀링 층을 번갈아 배치하여 크기를 줄여나갑니다.  
    **풀링:**  
    현대에는 Max Pooling을 주로 쓰지만 당시에는 **Average Pooling**을 사용했습니다.  
    **출력:**  
    마지막에 Fully Connected Layer을 거쳐 0~9까지의 숫자를 인식합니다. 당시에는 Softmax가 아닌 다른 분류기를 사용했습니다.

**규모 및 한계:**  
약 6만 개의 파라미터를 가지며 최신 신경망(1000만~1억 개)에 비해 매우 작습니다. 활성화 함수로 ReLU 대신 **Sigmoid나 tanh**를 사용했습니다.

### 2. 신경망의 공통 패턴 
**구조적 패턴:**  
신경망이 깊어질수록 **이미지의 높이와 너비는 줄어들고 채널(필터)의 수는 증가**하는 경향이 있습니다. '합성곱-풀링-합성곱-풀링-완전연결'로 이어지는 배치는 지금도 흔히 사용됩니다.


### 3. AlexNet (2012년)
컴퓨터 비전 커뮤니티가 딥러닝의 가능성을 확신하게 된 계기가 된 모델입니다.

**구조 및 특징:**  
    **입력:**  
    227x227x3 컬러 이미지를 사용합니다(논문엔 224로 표기되나 계산상 227이 적절함).  
    **구성:**  
    LeNet과 유사하지만 훨씬 큽니다. 첫 층에서 11x11 필터(스트라이드 4)를 사용하여 이미지 크기를 대폭 줄입니다.  
    **혁신:**  
    **ReLU 활성화 함수**를 사용하여 성능을 높였으며 약 6천만 개의 파라미터를 가집니다.  
    **특이점:**  
    당시 GPU 성능 한계로 두 개의 GPU에 층을 나누어 훈련했습니다. 또한 '지역 응답 정규화(Local Response Normalization)'라는 층을 사용했으나 이후 연구에서 중요하지 않다고 밝혀져 현재는 거의 사용되지 않습니다.

### 4. VGG-16
매우 규칙적이고 간결한 구조가 특징인 네트워크입니다.

**핵심 철학:**  
복잡한 하이퍼파라미터 대신 **모든 합성곱 층에 3x3 필터(스트라이드 1 same padding) 풀링 층에 2x2(스트라이드 2)**라는 통일된 규칙을 적용했습니다.

**구조적 특징:**  
    합성곱 층을 거칠 때마다 채널 수가 64 -> 128 -> 256 -> 512로 정확히 **2배씩 증가**하고 풀링 층에서는 높이와 너비가 절반으로 줄어듭니다.
    이러한 체계적인 구조 덕분에 구조적으로 매우 매력적이나 약 1억 3천 8백만 개의 파라미터를 가진 거대한 네트워크라는 단점(훈련 비용 증가)이 있습니다.
이름의 '16'은 가중치를 가진 층이 16개라는 뜻입니다.




## C4W2L03 ResNets


### **1. 깊은 신경망 학습의 어려움과 ResNet의 등장**
아주 깊은 신경망을 훈련할 때 발생하는 주요 문제는 **vanishing gradients** 이나 **exploding gradients**입니다. 이를 해결하기 위해 한 층의 활성값을 훨씬 깊은 층으로 직접 전달하는 **Skip Connection**을 도입했으며 이를 통해 100층이 넘는 깊이의 신경망인 **ResNet(Residual Network)**을 학습시킬 수 있게 되었습니다.

### **2. 잔여 블록(Residual Block)의 작동 원리**
일반적인 신경망의 흐름(Main Path)은 선형 연산과 ReLU 활성화 함수를 차례로 거칩니다. ResNet은 여기에 **Short cut**을 추가하여 입력값 $a^{[l]}$을 복제한 뒤 신경망의 더 깊은 층으로 단번에 보냅니다. 핵심은 이 $a^{[l]}$ 값이 두 번째 층의 **ReLU 비선형성을 적용하기 직전에 더해진다**는 점입니다.

### **3. 수식적 표현과 구조**
이 과정을 수식으로 표현하면 기존의 $a^{[l+2]} = g(z^{[l+2]})$ 대신 **$a^{[l+2]} = g(z^{[l+2]} + a^{[l]})$**가 됩니다. 이렇게 스킵 연결이 포함된 구조를 **'잔여 블록(Residual Block)'**이라고 부르며 ResNet은 이러한 잔여 블록들을 쌓아서 구축됩니다. 이 구조는 Kaiming He 등이 발견한 것으로 층을 건너뛰어 정보를 전달함으로써 훨씬 깊은 신경망 훈련을 가능하게 합니다.

### **4. 평형망(Plain Network) vs ResNet의 성능 차이**
스킵 연결이 없는 일반적인 네트워크(평형망)는 이론상 깊어질수록 성능이 좋아야 하지만 실제로는 층이 매우 깊어지면 최적화가 어려워져 **훈련 오류가 오히려 증가**하는 경향을 보입니다. 반면 두 층마다 스킵 연결을 추가하여 만든 **ResNet**은 층의 개수가 늘어나도 훈련 오류가 계속해서 감소하는 성능을 보여줍니다.

ResNet은 중간 활성값을 깊은 층으로 전달함으로써 **경사 소실 문제 해결**에 큰 도움을 줍니다. 이를 통해 성능 저하 없이 100개 이상의 층 심지어 수천 개의 층을 가진 신경망도 훈련이 가능해집니다.



## C4W2L04 Why ResNets Work


### 1. ResNet의 학습 효과와 기본 전제
**깊은 네트워크의 훈련 문제 해결:**  
일반적인 신경망은 층이 깊어질수록 훈련 세트를 학습하는 데 어려움을 겪고 성능이 저하되는 경향이 있습니다.

**ResNet의 목표:**  
ResNet은 층을 깊게 쌓더라도 최소한 훈련 세트에 대한 성능이 떨어지지 않도록 보장하며 이를 통해 훈련 효율을 높이는 것을 목표로 합니다.

### 2. 잔차 블록(Residual Block)의 작동 원리
**스킵 연결(Skip Connection) 추가:**  
기존 신경망의 활성값 $a^{[l]}$에서 두 개의 층을 더 거쳐 $a^{[l+2]}$를 만드는 구조에 입력을 출력에 바로 더해주는 '지름길(shortcut)'을 추가합니다.

**수식의 변화:**  
일반적인 네트워크와 달리 잔차 블록의 활성값 공식은 다음과 같이 변합니다.
    $a^{[l+2]} = g(z^{[l+2]} + a^{[l]})$
    여기서 $g$는 활성화 함수(주로 ReLU)입니다.

### 3. 항등 함수(Identity Function) 학습의 용이성 (핵심)
**가중치 붕괴와 항등 매핑:**  
L2 규제(Regularization)나 가중치 붕괴(Weight Decay)를 적용하면 가중치 $w^{[l+2]}$와 편향 $b^{[l+2]}$가 0에 가까워집니다.

**쉽게 만들어지는 항등 함수:**  
만약 $w$와 $b$가 0이 되면 $z^{[l+2]}$ 항은 사라지고 $a^{[l+2]} = g(a^{[l]})$만 남습니다. ReLU 함수를 사용하므로 입력값이 0 이상(이전 층의 결과)일 경우 $a^{[l+2]} = a^{[l]}$이 됩니다.

**성능 보장의 원리:**  
일반적인 깊은 신경망은 층이 추가되었을 때 입력을 그대로 출력하는 '항등 함수'조차 학습하기 어려워 성능이 떨어집니다. 반면 ResNet은 가중치를 0으로 만드는 것만으로도 쉽게 항등 함수를 구현할 수 있습니다.

**결과:**  
층을 추가하더라도 **최악의 경우 기존 성능을 유지(항등 함수)**할 수 있으며 학습을 통해 유의미한 패턴을 발견하면 성능을 더 향상시킬 수 있게 됩니다.

### 4. 차원(Dimension) 일치와 처리 방법
**동일 차원 전제:**  
$z^{[l+2]}$와 $a^{[l]}$을 더하기 위해서는 두 벡터의 차원이 같아야 합니다. ResNet에서는 주로 '동일 합성곱(Same Convolution)'을 사용하여 입출력 차원을 유지합니다.

**차원이 다를 경우:**  
풀링 층 등을 거쳐 차원이 바뀌는 경우(예: 128차원 → 256차원) $W_s$라는 행렬을 도입하여 $a^{[l]}$의 차원을 변환한 뒤 더해줍니다.  
    **$W_s$ 구성 방법:**  
    학습 가능한 변수로 구성된 행렬을 사용할 수도 있고 0을 채워 넣는 제로 패딩(Zero-padding) 방식을 사용할 수도 있습니다.

### 5. 전체 네트워크 구조 (Plain Net vs ResNet)
**구조적 차이:**  
일반적인 네트워크(Plain Network)에 스킵 연결을 추가하면 ResNet이 됩니다. 대부분 3x3 동일 합성곱을 사용하여 차원을 유지하며 연결합니다.

**풀링 층 처리:**  
중간에 풀링 층이 있어 차원이 변경될 때마다 $W_s$ 행렬을 사용하여 차원을 맞춰주는 조정을 거칩니다.

**ResNet은 스킵 연결을 통해 네트워크가 깊어져도 최소한 '항등 함수'를 쉽게 학습할 수 있게 하여 성능 저하를 막고 나아가 더 깊은 층을 통해 성능을 향상시킬 수 있는 구조입니다.**

## C4W2L05 Network In Network


### **1. 1x1 합성곱의 기본 개념과 오해**
단일 채널(2D 이미지)에서 1x1 합성곱을 적용하면 단순히 이미지에 숫자를 곱하는 연산이 되어 별 의미가 없어 보일 수 있습니다.
하지만 채널이 많은 경우(예: 6x6x32 입력)에는 1x1 합성곱이 매우 중요한 의미를 갖게 됩니다.

### **2. 연산 메커니즘: 채널 전체를 아우르는 처리**
1x1 합성곱은 이미지를 훑으며 각 위치의 모든 채널 값(예: 32개의 숫자)을 입력으로 받습니다.
이 값들을 필터와 곱하고 **ReLU 비선형성**을 적용하여 하나의 값으로 출력합니다. 이는 마치 하나의 뉴런이 해당 위치의 모든 채널 데이터를 입력받아 처리하는 것과 같습니다.
여러 개의 필터를 사용하면 출력 또한 여러 채널을 갖게 됩니다.

### **3. "Network In Network"의 의미**
이 연산은 각 픽셀 위치마다 **완전 연결 신경망(Fully Connected Network)**을 적용하는 것과 동일한 효과를 냅니다.
입력 채널 수(32개)만큼의 데이터를 받아 필터의 개수만큼 출력 값을 만들어냅니다. 논문에서는 이를 Network In Network라고 표현합니다.
이 개념은 이후 Inception 신경망 등 다른 구조에 많은 영감을 주었습니다.

### **4. 핵심 기능 1: 채널 수 축소 (Dimension Reduction)**
높이와 너비를 줄이는 데 풀링(Pooling) 층을 쓴다면 **채널 수($n_C$)를 줄이는 데는 1x1 합성곱을 사용**합니다.
예를 들어 28x28x192 입력을 28x28x32로 줄이고 싶다면 32개의 1x1 필터를 사용하여 채널 수를 효과적으로 감소시킬 수 있습니다.

### **5. 핵심 기능 2: 비선형성과 네트워크 깊이 추가**
채널 수를 줄이지 않고 그대로 유지하더라도 1x1 합성곱 층을 추가하면 **비선형성(ReLU)**을 더해줄 수 있습니다.
이를 통해 네트워크가 더 복잡한 함수를 학습할 수 있게 되며 채널 수를 조절하거나 네트워크의 깊이를 더하는 데 매우 유용하게 사용됩니다.

---
**ai:**  
1x1 합성곱을 **'정보 압축기'** 혹은 **'특징 재해석기'**라고 생각하면 이해하기 쉽습니다. 이미지의 크기(가로x세로)는 건드리지 않으면서 그 위치에 쌓여 있는 수많은 정보(채널)들을 요약(압축)하거나 새로운 관점으로 조합(재해석)하여 다음 단계로 넘겨주는 역할을 합니다.



## C4W2L06 Inception Network Motivation
인셉션 네트워크의 기본 아이디어와 1x1 합성곱을 활용한 연산 비용 절감(병목 층) 원리를 설명합니다.

### **1. 인셉션 네트워크의 핵심 아이디어: "모두 다 사용하기"**
**필터 선택의 고민 해결:**  
신경망 층을 설계할 때 1x1 3x3 5x5 필터 중 무엇을 쓸지 혹은 풀링 층을 쓸지 고민하는 대신 인셉션 네트워크는 **이들을 모두 적용**합니다.

**구조:**  
입력값(예: 28x28x192)에 대해 다양한 필터 연산과 풀링 연산을 수행한 뒤 그 결과들을 모두 쌓아(Concatenate) 하나의 거대한 출력으로 만듭니다.  
    이때 출력의 높이와 너비를 입력과 동일하게(28x28) 유지하기 위해 **'동일 합성곱(Same convolution)'**과 패딩을 사용합니다.
    특히 풀링 층의 경우 크기를 유지하기 위해 패딩을 사용하는 독특한 방식을 취합니다.

**효과:**  
네트워크가 학습을 통해 스스로 최적의 필터 조합을 찾아내게 됩니다.

### **2. 문제점: 막대한 연산 비용 (Computational Cost)**
**비용 폭증:**  
모든 필터를 다 쓰면 연산량이 급격히 늘어납니다. 예를 들어 28x28x192 입력에 5x5 필터 32개를 바로 적용하면 약 **1억 2천만 번**의 곱셈 연산이 필요합니다.

**계산:**  
(출력 픽셀 수 28x28x32) $\times$ (필터 크기 5x5x192) $\approx$ 1억 2천만.

### **3. 해결책: 병목 층(Bottleneck Layer)의 도입**
**1x1 합성곱 활용:**  
연산 비용을 줄이기 위해 5x5 합성곱을 하기 전에 **1x1 합성곱**을 먼저 수행하여 채널 수를 줄입니다(예: 192 채널 $\rightarrow$ 16 채널).

**병목(Bottleneck)의 의미:**  
큰 병에서 가장 좁은 부분인 병목처럼 데이터의 채널 수가 가장 작아지는 구간을 만들어 연산을 효율화하는 방식입니다.

### **4. 연산 비용 절감 효과 검증**
**단계별 계산:**  
1.  **압축 단계 (1x1):**  
    192개 채널을 16개로 줄이는 데 약 240만 번의 연산이 듭니다.
2.  **합성곱 단계 (5x5):**  
    줄어든 16개 채널에 5x5 필터를 적용하면 약 1000만 번의 연산이 듭니다.

**결과 비교:**  
총 연산량은 약 **1240만 번**으로 기존 1억 2천만 번에 비해 **약 1/10 수준으로 감소**합니다.

### **5. 결론**
인셉션 모듈은 다양한 크기의 필터를 모두 사용하여 네트워크 성능을 높이되 **병목 층(1x1 합성곱)**을 적절히 배치하여 연산 비용 문제를 해결하고 성능 저하 없이 효율적인 구조를 만들어냅니다.

---
**ai:**  
강의에서는 이 과정을 **유리병의 목(Bottleneck)**에 비유합니다.
넓은 병(큰 데이터)의 내용물을 그대로 쏟아부으려 하면 넘치거나 감당하기 힘들지만(연산 비용 과다) **병목(1x1 합성곱)**을 통해 흐름을 좁혀서 통제한 뒤 다시 컵에 따르면(5x5 합성곱) 내용물을 흘리지 않고 원하는 만큼 효율적으로 담아낼 수 있는 원리와 같습니다.


## C4W2L07 Inception Network

### **1. 인셉션 모듈(Inception Module)의 구성**

**기본 아이디어:**  
이전 영상에서 다룬 1x1 3x3 5x5 합성곱(Convolution) 등의 구성 요소들을 조합하여 하나의 모듈을 구축합니다.

**합성곱 층:**  
예를 들어 $28 \times 28 \times 192$ 크기의 입력값이 있다면 계산 비용을 줄이기 위해 1x1 합성곱을 사용하여 채널 수를 줄인 뒤 3x3이나 5x5 합성곱을 수행합니다.

**풀링(Pooling) 층의 처리:**  
    모듈 내에 풀링 층을 추가할 때 일반적으로 '동일 패딩(Same padding)'을 적용한 최대 풀링(Max pooling)을 사용하면 출력의 높이와 너비는 유지되지만 채널 수(깊이)가 입력과 동일하게(예: 192개) 유지되어 채널이 너무 많아지는 문제가 발생합니다.
    이를 해결하기 위해 풀링 층 뒤에 **1x1 합성곱 층**을 추가하여 채널 수를 줄여줍니다(예: 32개로 축소).

**채널 연결(Concatenation):**  
1x1 합성곱 3x3 합성곱 5x5 합성곱 그리고 풀링 층을 거친 결과들을 모두 모아 하나로 연결합니다. 이렇게 만들어진 블록 하나가 바로 '인셉션 모듈'입니다.

### **2. 인셉션 네트워크(GoogLeNet)의 구조**

**모듈의 반복:**  
인셉션 네트워크는 앞서 만든 인셉션 모듈을 여러 개 쌓아서 구성한 것입니다.

**전체 구조:**  
복잡해 보이지만 자세히 보면 인셉션 블록들이 반복되는 형태이며 차원을 줄이기 위해 블록들 사이에 최대 풀링 층이 추가되기도 합니다.

### **3. 곁가지(Side Branches)와 정규화**

**구조:**  
네트워크의 중간 은닉층에서 뻗어 나온 곁가지들이 존재합니다. 이들은 자체적인 완전 연결 층(Fully connected layer)과 소프트맥스(Softmax) 층을 가지고 예측을 수행합니다.

**역할:**  
이 곁가지들은 중간 층에서 계산된 특성들이 이미지 분류에 유효한지 확인하며 네트워크에 정규화(Regularization) 효과를 주어 과대적합(Overfitting)을 방지하는 역할을 합니다.

### **4. 이름의 유래와 발전**

**GoogLeNet:**  
이 네트워크는 구글 연구팀에 의해 개발되었으며 딥러닝의 시초인 'LeNet'에 경의를 표하기 위해 'GoogLeNet'이라고 명명되었습니다.

**Inception:**  
"더 깊이 가야 해(We need to go deeper)"라는 대사로 유명한 영화 '인셉션'의 인터넷 밈(Meme)에서 이름을 따왔습니다.

이후 인셉션 v2 v3 v4 등 개선된 버전들이 나왔으며 ResNet의 스킵 연결(Skip connection)을 결합하여 성능을 높인 버전도 존재합니다. 하지만 이 모든 것은 다수의 인셉션 모듈을 쌓는다는 기본 개념에 기초합니다.


## C4W2L08 Using Open Source Implementation


### **1. 오픈 소스 활용의 중요성 (강의 초반)**
효과적인 신경망 구조를 배웠더라도 실제 구현 시 **하이퍼파라미터 조정이나 학습률 감쇠(learning rate decay)** 등의 세부 사항 때문에 논문만 읽고 똑같이 구현하는 것은 매우 어렵습니다.
심지어 딥러닝 전공 박사 과정 학생들도 논문만으로는 구현에 어려움을 겪곤 합니다.
다행히 많은 연구자가 자신의 코드를 GitHub와 같은 **오픈 소스로 공유**하고 있으며 이를 활용하면 처음부터 직접 구현하는 것보다 훨씬 빠르게 작업을 진행할 수 있습니다.

### **2. GitHub에서 코드 찾기 및 다운로드 시연 (강의 중반)**
강의에서는 **ResNet**을 예시로 들어 GitHub에서 검색하는 과정을 보여줍니다.
검색 결과 중 원저자가 작성한 저장소를 선택하고 **MIT 라이선스**와 같이 자유롭게 사용할 수 있는 라이선스인지 확인하는 것이 좋습니다.
`git clone` 명령어와 해당 URL을 사용하여 코드를 로컬 컴퓨터로 다운로드하는 방법을 시연합니다.

### **3. 코드 확인 및 실무 적용 (강의 후반)**
다운로드한 파일들을 살펴보면 신경망의 구체적인 구조(예: 101개의 층을 가진 ResNet)를 정의한 파일(예: `.prototxt`) 등을 확인할 수 있습니다.
컴퓨터 비전 애플리케이션을 개발할 때는 처음부터 구현하기보다 **오픈 소스를 다운로드하여 시작하는 것이 자연스러운 작업 흐름**입니다.
오픈 소스를 활용하면 누군가 거대한 데이터셋과 GPU로 미리 훈련해 둔 네트워크를 사용할 수 있어 다음 강의 주제인 **전이 학습(Transfer Learning)**을 적용하기에도 유리합니다.




## C4W2L09 Transfer Learning

### **1. 전이 학습(Transfer Learning)의 개념과 필요성**
컴퓨터 비전 문제를 해결할 때 가중치를 무작위로 초기화하여 처음부터 시작하는 대신 다른 연구자들이 대규모 데이터셋(ImageNet MS-COCO 등)으로 이미 훈련시켜 놓은 신경망 구조와 가중치를 다운로드하여 사용하는 것이 훨씬 효과적입니다.
이러한 오픈 소스 모델들은 고성능 장비로 오랜 기간 훈련된 결과물이므로 이를 새로운 작업의 초기화 자료로 활용하면 '지식의 전이'를 통해 훈련 시간을 단축하고 성능을 높일 수 있습니다.

### **2. 예시: 고양이 분류기 만들기 (Tigger vs Misty vs 둘 다 아님)**
자신이 키우는 고양이(Tigger Misty) 혹은 그 외의 대상을 구분하는 분류기를 만든다고 가정해 봅시다. 이때 사용할 수 있는 훈련 데이터의 양은 매우 적을 것입니다.
이 문제를 해결하기 위해 오픈 소스 신경망 코드와 가중치를 다운로드한 후 기존의 1000개 클래스를 분류하던 **소프트맥스(Softmax) 층을 제거하고** 우리의 목적에 맞는 3개의 클래스(Tigger Misty None)를 출력하는 새로운 소프트맥스 유닛을 만듭니다.

### **3. 데이터 양에 따른 훈련 전략**

**경우 A: 데이터 세트가 작을 때 (대부분의 층 동결)**
    기존 네트워크의 모든 층의 변수를 고정(Freeze)하고 새로 만든 소프트맥스 층의 변수만 훈련시킵니다.
    딥러닝 프레임워크에서 `trainable = 0` 또는 `freeze = 1`과 같은 설정을 통해 이전 층들의 훈련을 막을 수 있습니다.  
    **최적화 팁:**  
    이전 층들은 고정되어 있으므로 모든 훈련 이미지에 대해 이 층들을 통과한 활성값(특성 벡터)을 미리 계산하여 디스크에 저장해 둡니다. 이렇게 하면 훈련 시마다 거대한 신경망을 다시 계산할 필요 없이 저장된 값으로 소프트맥스 층만 빠르게 훈련할 수 있습니다.

**경우 B: 데이터 세트가 좀 더 많을 때 (일부 층 해제)**
    데이터가 더 확보된다면 마지막 몇 개의 층을 동결에서 해제하여 훈련에 포함시키거나 뒤쪽 층들을 제거하고 새로운 은닉층을 추가하여 훈련할 수 있습니다.
    데이터가 많아질수록 동결시키는 층의 개수는 줄이고 훈련시킬 층의 개수는 늘립니다.

**경우 C: 데이터 세트가 아주 많을 때 (전체 네트워크 미세 조정)**
    매우 큰 데이터 세트가 있다면 다운로드한 가중치 전체를 단순히 **초기값**으로만 사용하고 네트워크의 모든 층을 새롭게 훈련(경사 하강법 적용)시킬 수 있습니다.


컴퓨터 비전 분야에서는 오픈 소스 데이터 세트가 방대하고 훈련에 많은 리소스가 들기 때문에 전이 학습을 통해 미리 학습된 가중치를 초기값으로 사용하는 것이 매우 일반적이고 유용합니다.
예외적으로 아주 큰 데이터 세트와 예산을 가진 경우가 아니라면 컴퓨터 비전 응용 프로그램을 구축할 때 전이 학습은 거의 필수적인 과정입니다.

---
**ai:**  
전이 학습은 **"유명 셰프가 며칠 동안 정성 들여 끓인 '육수(사전 훈련된 가중치)'를 받아와서 내가 원하는 '토핑(소프트맥스 층)'만 얹어 나만의 요리(새로운 분류기)를 완성하는 것"**과 같습니다.
재료가 적으면(데이터가 적으면) 육수의 맛을 그대로 살리고 토핑만 조심스럽게 올리고(모든 층 동결)
재료가 아주 많으면(데이터가 많으면) 육수를 베이스로 쓰되 내 입맛에 맞게 다시 푹 끓여서(전체 재학습) 완전히 새로운 맛을 낼 수도 있습니다.


## C4W2L10 Data Augmentation


### **1. 데이터 확대의 필요성**
**데이터의 중요성:**  
컴퓨터 비전 모델은 픽셀 입력을 통해 대상을 식별하는 복잡한 함수를 학습해야 하므로 대부분의 경우 데이터가 많을수록 성능이 향상됩니다.

**활용:**  
전이 학습을 통해 미리 훈련된 가중치를 사용하든 처음부터 직접 훈련하든 데이터 확대는 컴퓨터 비전 모델 훈련에 큰 도움이 됩니다.

### **2. 기본적인 데이터 확대 기법**
**미러링(Mirroring):**  
가장 간단한 방식으로 이미지를 수직 축으로 대칭(뒤집기)시키는 것입니다. 고양이 사진을 뒤집어도 여전히 고양이이므로 데이터의 정체성을 보존하는 좋은 기술입니다.

**무작위 크로핑(Random Cropping):**  
이미지의 일부분을 무작위로 잘라내어 서로 다른 훈련 예시들을 만드는 방식입니다. 잘라낸 부분이 대상을 완벽히 포함하지 않을 수도 있지만 실제로는 데이터 양을 늘리는 데 매우 효과적이라 자주 사용됩니다.
*참고:* 회전(Rotation) 전단(Shearing) 비틀기 등도 이론적으로 가능하지만 복잡성 때문에 미러링이나 크로핑보다는 덜 빈번하게 사용됩니다.

### **3. 색 변환(Color Shifting)**
**원리:**  
RGB 각 채널에 임의의 값을 더하거나 빼서 이미지의 색조를 바꿉니다.

**목적:**  
조명의 색(예: 노란 햇빛 실내등)이 바뀌어도 대상(예: 고양이)의 정체성은 변하지 않는다는 점을 학습시킵니다. 이를 통해 학습 알고리즘이 색의 변화에 더 강인하게 반응하도록 만듭니다.

### **4. 고급 기법: PCA 색 확대**
**개념:**  
AlexNet 논문에서 사용된 방식으로 **주성분 분석(PCA)**을 이용합니다.

**방식:**  
이미지에 많이 포함된 주된 색상(예: 보라색 이미지라면 빨강과 파랑)에는 큰 변화를 주고 적게 포함된 색상에는 적은 변화를 주어 전체적인 색조 균형을 유지하며 데이터를 변형합니다.

### **5. 데이터 확대 구현 시스템**
**병렬 처리:**  
훈련 데이터는 보통 하드디스크에 저장되어 있습니다. CPU 스레드가 이미지를 불러와 변형(왜곡 색 변환 등)을 수행하여 미니 배치를 만듭니다.

**파이프라인:**  
CPU가 데이터를 준비하는 동안 GPU(또는 다른 프로세스)는 준비된 데이터를 넘겨받아 실제로 신경망을 훈련시킵니다. 이 두 과정은 동시에 병렬적으로 실행되어 효율을 높입니다.

**팁:**  
데이터 확대에도 하이퍼파라미터(얼마나 자를지 색을 얼마나 바꿀지 등)가 존재합니다. 처음에는 오픈 소스 구현이나 입증된 설정을 참고하여 시작하는 것이 좋습니다.

**ai:**  

이 과정은 **"식당 주방의 분업 시스템"** 과 같습니다.  
**하드디스크(창고):**  
식재료(이미지)가 보관된 곳입니다.  
**CPU(재료 손질 담당):**  
창고에서 재료를 가져와 씻고 자르고 양념을 쳐서(데이터 확대: 크로핑 색 변환) 요리하기 좋은 상태로 준비합니다.  
**GPU(메인 셰프):**  
손질된 재료를 넘겨받아 쉴 새 없이 요리(모델 훈련)를 합니다.
재료 손질과 요리가 동시에 이루어지기 때문에(병렬 처리) 주방은 멈추지 않고 효율적으로 돌아갑니다.


## C4W2L11 State of Computer Vision
컴퓨터 비전 분야의 딥러닝 현황 데이터와 아키텍처의 관계 그리고 벤치마킹 팁과 실무 적용의 차이를 다루고 있습니다.

### **1. 머신러닝 문제의 스펙트럼과 데이터 가용성**
머신러닝 문제는 데이터의 양에 따라 스펙트럼상에 위치합니다. 음성 인식은 비교적 데이터가 충분한 편이지만 이미지 인식(Image Recognition)은 픽셀 단위의 복잡성 때문에 여전히 더 많은 데이터가 필요합니다.
특히 **물체 인식(Object Detection)** 은 이미지 내에서 물체의 위치(경계 상자 Bounding Box)까지 표시해야 하므로 데이터 구축 비용이 비싸고 이미지 인식보다 데이터가 훨씬 적습니다.

### **2. 데이터 양과 설계(Hand-engineering)의 반비례 관계**
**데이터가 많은 경우:**  
단순한 알고리즘과 신경망 구조를 사용해도 되며 수작업 설계(Hand-engineering)가 적게 들어갑니다. 신경망이 스스로 학습하도록 두면 됩니다.

**데이터가 적은 경우:**  
좋은 성능을 내기 위해 수작업 설계 즉 **복잡한 네트워크 구조 설계**나 특성 엔지니어링에 더 많이 의존해야 합니다. 이를 부정적으로는 '해킹(hacks)'이 많아진다고도 표현합니다.
컴퓨터 비전은 역사적으로 데이터가 부족했기 때문에 이를 보완하기 위해 매우 복잡하고 정교한 네트워크 구조들이 발전해 왔습니다.

### **3. 벤치마킹(대회)과 실무(제품)의 차이**
연구자들은 표준화된 벤치마킹 데이터셋에서 좋은 성적을 내는 것에 집중하며 이는 논문 작성과 커뮤니티 발전에 도움이 됩니다.
하지만 벤치마킹에서 1~2%의 성능 향상을 가져오는 기술이 **실제 제품(Production)에는 사용하기 어려운 경우**가 많습니다. 대표적인 두 가지 기법은 다음과 같습니다:
1.  **앙상블(Ensembling):**  
    3~7개의 신경망을 독립적으로 훈련시킨 뒤 그 예측값들의 평균을 내는 방식입니다. 성능은 오르지만 메모리를 많이 차지하고 실행 속도가 3~15배 느려져 실제 제품에는 거의 쓰이지 않습니다.
2.  **다중 크로핑(Multi-cropping):**  
    테스트 이미지의 중앙과 네 모서리 그리고 대칭 이미지 등을 잘라내어(예: 10-crop) 각각 예측한 뒤 평균을 냅니다. 앙상블보다 메모리는 덜 차지하지만 여전히 실행 속도를 늦춥니다.

### **4. 실무자를 위한 조언: 전이 학습과 오픈 소스 활용**
컴퓨터 비전은 데이터가 상대적으로 적은 문제(특히 물체 인식 등)를 다룰 때가 많으므로 **전이 학습(Transfer Learning)**이 큰 도움이 됩니다.
특정 문제에서 잘 작동하는 신경망 구조는 다른 문제에서도 잘 작동하는 경향이 있습니다. 따라서 처음부터 직접 설계하기보다는 **오픈 소스 구현이나 이미 훈련된(Pre-trained) 모델을 가져와서 시작**하는 것이 훨씬 효율적입니다.
이는 누군가가 이미 수많은 GPU를 사용해 최적의 하이퍼 파라미터를 찾아놓은 결과물을 활용하는 현명한 방법입니다.


